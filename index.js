const fs = require('fs').promises;
const path = require('path');
const process = require('process');
const {authenticate} = require('@google-cloud/local-auth');
const {google} = require('googleapis');

// If modifying these scopes, delete token.json.
const SCOPES = ['https://mail.google.com/', 'https://www.googleapis.com/auth/gmail.readonly', 'https://www.googleapis.com/auth/gmail.modify'];
// The file token.json stores the user's access and refresh tokens, and is
// created automatically when the authorization flow completes for the first
// time.
const TOKEN_PATH = path.join(process.cwd(), 'token.json');
const CREDENTIALS_PATH = path.join(process.cwd(), 'credentials.json');

/**
 * Reads previously authorized credentials from the save file.
 *
 * @return {Promise<OAuth2Client|null>}
 */
async function loadSavedCredentialsIfExist() {
  try {
    const content = await fs.readFile(TOKEN_PATH);
    const credentials = JSON.parse(content);
    return google.auth.fromJSON(credentials);
  } catch (err) {
    return null;
  }
}

/**
 * Serializes credentials to a file compatible with GoogleAUth.fromJSON.
 *
 * @param {OAuth2Client} client
 * @return {Promise<void>}
 */
async function saveCredentials(client) {
  const content = await fs.readFile(CREDENTIALS_PATH);
  const keys = JSON.parse(content);
  const key = keys.installed || keys.web;
  const payload = JSON.stringify({
    type: 'authorized_user',
    client_id: key.client_id,
    client_secret: key.client_secret,
    refresh_token: client.credentials.refresh_token,
  });
  await fs.writeFile(TOKEN_PATH, payload);
}

/**
 * Load or request or authorization to call APIs.
 *
 */
async function authorize() {
  let client = await loadSavedCredentialsIfExist();
  if (client) {
    return client;
  }
  client = await authenticate({
    scopes: SCOPES,
    keyfilePath: CREDENTIALS_PATH,
  });
  if (client.credentials) {
    await saveCredentials(client);
  }
  return client;
}

const LABEL = 'autoGenerated'; //Label for e-mails replied through this application

/**
 * Create the label in the user's account.
 *
 * @param {google.auth.OAuth2} auth An authorized OAuth2 client.
 */
async function createLabel(auth) {
  
  const gmail = google.gmail({version: 'v1', auth});
  try {
    const res = await gmail.users.labels.list({
      auth,
      userId: 'me',
    });

    const labels = res.data.labels;
    let labelId;
    
    for(const label of labels){
      if(label.name === LABEL){
        labelId = label.id;
      }
    }

    if(!labelId){
      await gmail.users.labels.create({
        auth,
        userId: 'me',
        resource: { name: LABEL, labelListVisibility: 'labelShow', messageListVisibility: 'show' },
      });
      console.log(`Label "${LABEL}" created.`);
    } else {
      console.log(`Label ${LABEL} already exist!`);
    }

  } catch (err) {
    console.error(`Error creating label: ${err.message}`);
  }
}

/**
 * Check Unread and New E-mails and send back the autogenerated reply.
 * 
 * @param {google.auth.OAuth2} auth An authorized OAuth2 Client.
 */
async function checkUnreadEmailandReply(auth) {
  const gmail = google.gmail({ version: 'v1', auth });
  
  try {
    const unreadEmails = await gmail.users.messages.list({
      auth,
      userId: 'me',
      q: 'is:unread',
    });

    const messages = unreadEmails.data.messages;

    if (messages && messages.length > 0) {
      for (const message of messages) {
        const email = await gmail.users.messages.get({
          userId: 'me',
          id: message.id,
        });

        const threadId = email.data.threadId;
        const emailHeaders = email.data.payload.headers;

        // Check if the thread has replies from the authenticated user
        const hasReplies = await hasRepliesFromUser(auth, threadId);

        if (!hasReplies) {
          // If there are no replies, send a new email as a reply and add label to the thread.
          await sendReply(auth, threadId, emailHeaders);
          await addLabel(auth, threadId);
        }
      }
    }
  } catch (err) {
    console.error(`Error reading messages: ${err.message}`);
  }
}

/**
 * Check if a thread has replies from the authenticated user.
 * 
 * @param {google.auth.OAuth2} auth An authorized OAuth2 client.
 * @param {string} threadId The ID of the thread.
 * @returns {Promise<boolean>} True if there are replies from the user; false otherwise.
 */
async function hasRepliesFromUser(auth, threadId) {
  const gmail = google.gmail({ version: 'v1', auth });

  try {
    const response = await gmail.users.threads.get({
      auth,
      userId: 'me',
      id: threadId,
    });
    const messages = response.data.messages;

    // Get Authenticated Users E-mail
    const res = await gmail.users.getProfile({
      auth,
      userId: 'me',
    });
    const emailAddress = res.data.emailAddress;

    // Check if there are messages in the thread from the authenticated user
    if(messages && messages.length > 0){
      for(const message of messages){
        const fromHeader = message.payload.headers.find(header => header.name === 'From');
        if(fromHeader.value === emailAddress){
          console.log('Message: Already Replied to all the unread e-mails');
          return true;
        }
      }
    }

    return false;

  } catch (err) {
    console.error(`Error checking replies: ${err.message}`);
    return false;
  }
}

/**
 * Send a new email as a reply to the specified thread.
 * 
 * @param {google.auth.OAuth2} auth An authorized OAuth2 client.
 * @param {string} threadId The ID of the thread.
 * @param {Array} headers The message headers.
 */
async function sendReply(auth, threadId, headers) {
  const gmail = google.gmail({ version: 'v1', auth });

  try {
    const toHeader = headers.find(header => header.name === 'To');
    const fromHeader = headers.find(header => header.name === 'From');
    const subjectHeader = headers.find(header => header.name === 'Subject');

    const newEmail = {
      from: toHeader.value,
      to: fromHeader.value,
      subject: `Re: ${subjectHeader.value}`,
      body: `Hello,

      Thank you for your email. I am currently out of the office on vacation and may have limited access to email.
      If your matter is urgent, please contact me on my phone.
      
      Best regards,
      Shishir Shukla`,
    };

    await gmail.users.messages.send({
      auth,
      userId: 'me',
      resource: {
        raw: await createRawMessage(newEmail),
        threadId: threadId,
      },
    });

    console.log('Reply sent successfully.');
  } catch (err) {
    console.error(`Error sending reply: ${err.message}`);
  }
}

/**
 * Create a raw email message from an object containing email details.
 * 
 * @param {Object} emailDetails Object containing email details (to, subject, body, etc.).
 * @returns {string} The raw email message.
 */
function createRawMessage(emailDetails) {
  const emailLines = [];

  // Add headers
  emailLines.push('From: ' + emailDetails.from);
  emailLines.push('To: ' + emailDetails.to);
  emailLines.push('Subject: ' + emailDetails.subject);
  emailLines.push('Content-Type: text/plain; charset="UTF-8"'); // Adjust content type as needed
  emailLines.push('MIME-Version: 1.0');

  // Add a blank line to separate headers from the body
  emailLines.push('');

  // Add body
  emailLines.push(emailDetails.body);

  // Combine lines into a single string
  const rawEmail = emailLines.join('\r\n');

  // Encode the raw email
  const encodedEmail = Buffer.from(rawEmail).toString('base64');

  return encodedEmail;
}

/**
 * Add Label to the thread of the sent e-mail.
 * 
 * @param {google.auth.OAuth2} auth An authorized OAuth 2.0 client.
 * @param {string} threadId The Id of the thread.
 */
async function addLabel(auth, threadId) {
  const gmail = google.gmail({ version: 'v1', auth });
  
  try{
    const res = await gmail.users.labels.list({
      auth,
      userId: 'me',
    });
    
    const labels = res.data.labels;
    
    let labelId;

    for(const label of labels){
      if(label.name === LABEL){
        labelId = label.id;
      }
    }
    
    await gmail.users.threads.modify({
      auth,
      userId: 'me',
      id: threadId,
      requestBody: {addLabelIds: [labelId]},
    });
    console.log(`Label: ${LABEL} added to the sent e-mail`);
  } catch(err) {
    console.error(`Error adding Label: ${err.message}`);
  }
}

/**
 * Get Random Interval for repeating the above steps.
 * 
 * @param {Number} max Maximum Number for the Interval (i.e 120 seconds)
 * @param {Number} min Minimum Number for the Interval (i.e 40 seconds)
 * @returns {Number} Interval between 45-120 seconds (in milliseconds).
 */
function getRandomInterval(min, max) {
  return Math.floor(Math.random() * (max - min + 1) + min);
}

authorize().then(createLabel).catch(console.error);  // Initial run to check for the Lablel and create one if not created.
authorize().then(checkUnreadEmailandReply).catch(console.error);  // Initial run to check Unread E-mails and send reply if not replied.

// Refresh the above steps at random intervals between 45-120 seconds. 
setInterval(() => {
  authorize().then(checkUnreadEmailandReply).catch(console.error);
}, getRandomInterval(45,120) * 1000);
